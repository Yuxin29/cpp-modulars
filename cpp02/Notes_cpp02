12.10.25 Sun

===============================CPP 02==========================

================ ex00 ================
--> Orthodox Canonical Form
Default constructor		    create and initiate
Copy constructor		    initiate this obj using another obj
Copy assignment operator	asign an obj to another exiting obj --->>check this != &other to avoid "self-asigning", return a *this to support assining chain
Destructor		            realise memory
exaple

16.10.25 Thurs 
--> Conventional naming habit in cpp
Type                            Recommended Style	Example                 Explanation
Member variables (non-static)	camelCase with _	_fixedPointValue	    Makes it clear that it’s a class member variable
Static variables (non-constant)	camelCase/prefix    s_	s_instanceCount	    Optional, often used to differentiate static members
Static / global constants	    (MACRO style)	    FRACTIONAL_BITS_NUMBER	Easy to identify as a constant at a glance
Functions / methods	            camelCase	        getRawBits()	        Common function naming convention
Class / struct names	        PascalCase	        Fixed	                Standard naming for C++ classes

================ ex01 ================

--->>> shift with _fractionalBitsNumber
Static const int _fractionalBitsNumber = 8;
---> we represent fractors with 8 bit binary nbr
---> example
42.42 * 2^8 = 42.42 * 256 ≈ 10859
reverse-> 10859 / 2^8 = 10859 / 256 ≈ 42.4219

--->    Overload << operator
std::cout << "hello"            << is an operater
operator <<
std::cout << "hello"  = operator<<(std::cout, "hello")
std::cout << someObject = operator<<(std::ostream& out, const TypeOfSomeObject& obj);

std::ostream& operator<<(std::ostream& out, const Fixed& fixed);

std::ostream& operator<<(std::ostream& out, const Fixed& fixed)
{
    out << fixed.toFloat();
    return out;
}
-->
std::cout << "a is " << a << std::endl;
<< a = operator<<(std::cout, a) 
WHYYY: because a is a Fix, self_defined class, 

Fixed a = Fixed(2.4f);
Fixed b = Fixed(2);
Fixed c = Fixed(0);
Fixed d = Fixed(INT_MAX);
    
Fixed const m(a / c);
Fixed const n(d * d);
std::cout << "testing deividing by 0: " << m << std::endl;
std::cout << "testing overflow:  " << n << std::endl;

You set d = Fixed(INT_MAX), so internally _fixedPointValue = 2147483647.
When you do d * d, the multiplication gives a huge number: 2147483647 * 2147483647 ≈ 4.6 × 10¹⁸.
After shifting right by 8 bits (for fixed-point scaling), it becomes ≈ 1.8 × 10¹⁶.
Casting this huge number to a 32-bit int causes overflow, and it wraps around.
The wrapped value ends up being -65536, which is why you see that output.